% Get parameters specified by user via GUI, stoted into the "params"
% structure.
%
% Example:
%   params = getparams_gui(EEG)
%
% Cedric Cannard, April 2023

function [params, abort] = getparams_gui(EEG)

abort = false;

%% Main GUI to select analysis, heart data type and name, visualization, and saving

% dropdown options to select
analysisTypes = { 'Heartbeat-evoked potentials (HEP)' 'Extract EEG & HRV features' 'Extract heart artifacts from EEG'};
dataTypes = { 'ECG' 'PPG' };

% callback functions
mode = "if get(gcbo,'value') == 2, set(findobj(gcbf,'userdata','analysis'),'enable','on'); else, set(findobj(gcbf,'userdata','analysis'),'enable','off'); end";
chanName = "tmpEEG = get(gcbf, 'userdata'); tmpchanlocs = tmpEEG.chanlocs; [tmp tmpval] = pop_chansel({tmpchanlocs.labels},'withindex','on'); set(findobj(gcbf,'tag','heart_channels'),'string',tmpval); clear tmp tmpEEG tmpchanlocs tmpval";
heartsig = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','heartsig'),'enable','on'); else, set(findobj(gcbf,'userdata','heartsig'),'enable','off'); end";

uilist = {
    {'style' 'text' 'string' 'Analysis to run:' 'fontweight' 'bold' } {'style' 'popupmenu' 'string' analysisTypes 'tag' 'analysis' 'callback' mode} ...
    {} ...
    {'style' 'text' 'string' 'Heart data type' 'fontweight' 'bold'} {'style' 'popupmenu' 'string' dataTypes 'tag' 'heart_signal' 'callback' heartsig 'value' 1} ...
    {} ...
    {'style' 'text' 'string' 'Select ECG/PPG channel(s):' 'fontweight' 'bold'} {'style' 'edit' 'tag' 'heart_channels'} {'style' 'pushbutton' 'string'  '...', 'enable' 'on' 'callback'  chanName } ...
    {} ...
    {'style' 'checkbox' 'tag' 'vis_outputs' 'string' ' Visualize outputs (recommended)' 'fontweight' 'bold' 'value' 1} {} ...
    {'style' 'checkbox' 'tag' 'save' 'string' ' Save outputs' 'fontweight' 'bold' 'value' 1} {} ...
        };

uigeom = { [.3 .6] ...
    1 ...
    [.6 .3] ...
    1 ...
    [.3 .3 .3] ...
    1 ...
    [1 .2]  ...
    [1 .2] };

% Launch GUI and get parameters from user
[res,~,~,params] = inputgui(uigeom,uilist,'pophelp(''pop_BrainBeats'')','BrainBeats EEGLAB plugin',EEG);
if isempty(res), abort = true; return; end  % Abort if no input
    
% Analysis choice and check data compatibility for that analysis
if params.analysis == 1
    params.analysis = 'hep';
elseif params.analysis == 2
    params.analysis = 'features';
elseif params.analysis == 3
    params.analysis = 'rm_heart';
else
    % If user didn't select any analysis, select based on data format
    if length(size(EEG.data)) == 2
        params.analysis = 'features';
        disp("You did not select which analysis you want to perform. Continuous data detected: performing feature-based analysis.")
    elseif length(size(EEG.data)) == 3
        params.analysis = 'hep';
        disp("You did not select which analysis you want to perform. Epoched data detected: performing HEP analysis.")
    end
end

% Extract heart signal type
params.heart_signal = lower(dataTypes{params.heart_signal});

% Extract heart channel names (if there are several)
if ~isempty(params.heart_channels)
    if contains(params.heart_channels,' ')
        params.heart_channels = split(params.heart_channels);
    end
else
    error('You must select your ECG/PPG channels from the list')
end

%% GUI for HEP with ECG

if strcmp(params.analysis, 'hep') && strcmp(params.heart_signal, 'ecg')

    % dropdown options for ECG
    searchback = {'Yes (default)' 'No'};
    rrArtMethod = { 'Shape-preserving piecewise cubic (default)' ...
        'Linear' 'Cubic' 'Nearest neighbor' 'Next neighbor' 'Previous neighbor' 'Spline'  ...
        'Cubic convolution' 'Modified Akima cubic' 'Remove them'};

    % dropdown options for EEG
    linefreq = {'60 Hz (US)' '50 Hz (Europe)'};
    refmethod = {'Infinity (default)' 'Average' 'Off'};
    filttype = {'Causal nonlinear (default)' 'Non-causal linear'};
    cleantrials = {'Aggressive' 'Moderate (default)' 'Conservative'};
    eeginterp = {'Yes (default)' 'No'};
    icamethod = {'Picard (fast)' 'Infomax (default)' 'Modified infomax (long but replicable)'};
    
    % Callback functions
    cleanHEART = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_heart'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_heart'),'enable','off'); end";
    cleanEEG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_eeg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_eeg'),'enable','off'); end";

    % GUI
    uilist = { ...
        {'style' 'checkbox' 'string' 'Preprocess ECG' 'fontweight' 'bold' 'tag' 'clean_heart' 'callback' cleanHEART 'value' 1} ...
        {} {'style' 'text' 'string' 'Peak threshold to detect R peaks:' } {'style' 'edit' 'string' '0.6' 'tag' 'ecg_peakthresh' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Perform searchback to detect R peaks:' } {'style' 'popupmenu' 'string' searchback 'tag' 'ecg_searchback' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Refractory period to detect R peaks:' } {'style' 'edit' 'string' '0.25' 'tag' 'ecg_refperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Physiologic limits to detect RR artifacts:' } {'style' 'edit' 'string' '[.375 2]' 'tag' 'rr_physlim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Gap limit to detect RR artifacts:' } {'style' 'edit' 'string' '2' 'tag' 'rr_gaplim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Change limit to detect RR artifacts:' } {'style' 'edit' 'string' '0.2' 'tag' 'rr_changelim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Interpolation method for RR artifacts:' } {'style' 'popupmenu' 'string' rrArtMethod 'tag' 'rr_correct' 'enable' 'on' 'userdata' 'clean_heart' } ...
        {'style' 'checkbox' 'string' 'Preprocess EEG' 'fontweight' 'bold' 'tag' 'clean_eeg' 'callback' cleanEEG 'value' 1} ...
        {} {'style' 'text' 'string' 'Re-reference data to:' } {'style' 'popupmenu' 'string' refmethod 'tag' 'ref' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2 }  ...
        {} {'style' 'text' 'string' 'Power line noise (Hz):' } {'style' 'popupmenu' 'string' linefreq 'tag' 'linenoise' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '40' 'tag' 'lowpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Filter type:' } {'style' 'popupmenu' 'string' filttype 'tag' 'filttype' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Longest flat lines before removing channel (in sec):' } {'style' 'edit' 'string' '5' 'tag' 'flatline' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Minimum correlation before removing channel (.5-.9):' } {'style' 'edit' 'string' '.65' 'tag' 'corrThresh' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Max portion tolerated before removing channel (0.1-0.5):' } {'style' 'edit' 'string' '.33' 'tag' 'maxBad' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Interpolate EEG channels after removal' } {'style' 'popupmenu' 'string' eeginterp 'tag' 'eeg_interp' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Method to reject bad segments:' } {'style' 'popupmenu' 'string' cleantrials 'tag' 'detectMethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'ICA method to extract artifactual components:' } {'style' 'popupmenu' 'string' icamethod 'tag' 'icamethod' 'enable' 'on' 'userdata' 'clean_eeg'}  ...
        {'style' 'checkbox' 'string' 'Visualize preprocessings' 'tag' 'vis_cleaning' 'fontweight' 'bold' 'value' 1}  ...
        {'style' 'checkbox' 'string' 'Keep heart channel in final output' 'tag' 'keep_heart' 'fontweight' 'bold' 'value' 0} ...
        };
    uigeom = {
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        .3 ...
        };
    [res,~,~,params2] = inputgui(uigeom,uilist,'pophelp(''brainbeats_process'')','BrainBeats: parameters for HEP mode',EEG);
    if isempty(res), abort = true; return; end % Abort if no input


%% GUI for HEP with PPG

elseif strcmp(params.analysis, 'hep') && strcmp(params.heart_signal, 'ppg')
    
    % dropdown options for PPG
    rrArtMethod = { 'Shape-preserving piecewise cubic (default)' ...
        'Linear' 'Cubic' 'Nearest neighbor' 'Next neighbor' 'Previous neighbor' 'Spline'  ...
        'Cubic convolution' 'Modified Akima cubic' 'Remove them'};

    % dropdown options for EEG
    linefreq = {'60 Hz (US)' '50 Hz (Europe)'};
    refmethod = {'Infinity (default)' 'Average' 'Off'};
    filttype = {'Causal nonlinear (default)' 'Non-causal linear'};
    eeginterp = {'Yes (default)' 'No'};
    cleantrials = {'Aggressive' 'Moderate (default)' 'Conservative'};
    icamethod = {'Picard (fast)' 'Infomax (default)' 'Modified infomax (long but replicable)'};

    % Callback functions
    cleanHEART = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_heart'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_heart'),'enable','off'); end";
    cleanEEG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_eeg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_eeg'),'enable','off'); end";

    % GUI
    uilist = { ...
        {'style' 'checkbox' 'string' 'Preprocess PPG' 'fontweight' 'bold' 'tag' 'clean_heart' 'callback' cleanHEART 'value' 1} ...
        {} {'style' 'text' 'string' 'Learning period to detect R waves (in s):' } {'style' 'edit' 'string' '8' 'tag' 'ppg_learnperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Learning threshold to detect R waves:' } {'style' 'edit' 'string' '5' 'tag' 'ppg_learnthresh' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Eye-closing period to detect R waves (0.4-0.8 s)' } {'style' 'edit' 'string' '0.65' 'tag' 'ppg_eyeclosing' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Expectation period to detect R waves (in s):' } {'style' 'edit' 'string' '5' 'tag' 'ppg_expctperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Slope window size to detect R waves (0.05-0.3):' } {'style' 'edit' 'string' '0.1' 'tag' 'ppg_slopewindow' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Physiologic limits to detect RR artifacts:' } {'style' 'edit' 'string' '[.375 2]' 'tag' 'rr_physlim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Gap limit to detect RR artifacts:' } {'style' 'edit' 'string' '2' 'tag' 'rr_gaplim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Change limit to detect RR artifacts:' } {'style' 'edit' 'string' '0.2' 'tag' 'rr_changelim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Interpolation method for RR artifacts:' } {'style' 'popupmenu' 'string' rrArtMethod 'tag' 'rr_correct' 'enable' 'on' 'userdata' 'clean_heart' } ...
        {'style' 'checkbox' 'string' 'Preprocess EEG' 'fontweight' 'bold' 'tag' 'clean_eeg' 'callback' cleanEEG 'value' 1} ...
        {} {'style' 'text' 'string' 'Re-reference data to:' } {'style' 'popupmenu' 'string' refmethod 'tag' 'ref' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Power line noise (Hz):' } {'style' 'popupmenu' 'string' linefreq 'tag' 'linenoise' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '40' 'tag' 'lowpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Filter type:' } {'style' 'popupmenu' 'string' filttype 'tag' 'filttype' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Longest flat lines before removing channel (in sec):' } {'style' 'edit' 'string' '5' 'tag' 'flatline' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Minimum correlation before removing channel (.5-.9):' } {'style' 'edit' 'string' '.65' 'tag' 'corrThresh' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Max portion tolerated before removing channel (0.1-0.5):' } {'style' 'edit' 'string' '.33' 'tag' 'maxBad' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Interpolate EEG channels after removal' } {'style' 'popupmenu' 'string' eeginterp 'tag' 'eeg_interp' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Method to reject bad segments:' } {'style' 'popupmenu' 'string' cleantrials 'tag' 'detectMethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'ICA method to extract artifactual components:' } {'style' 'popupmenu' 'string' icamethod 'tag' 'icamethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {'style' 'checkbox' 'string' 'Visualize preprocessings' 'tag' 'vis_cleaning' 'fontweight' 'bold' 'value' 1}  ...
        {'style' 'checkbox' 'string' 'Keep heart channel in final output' 'tag' 'keep_heart' 'fontweight' 'bold' 'value' 0} ...
        };
    uigeom = {
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        .3 ...
        };
    [res,~,~,params2] = inputgui(uigeom,uilist,'pophelp(''brainbeats_process'')','BrainBeats: parameters for HEP mode',EEG);
    if isempty(res), abort = true; return; end % Abort if no input

    %% GUI for Features-mode with ECG
elseif strcmp(params.analysis, 'features') && strcmp(params.heart_signal, 'ecg')


    % dropdown options
    searchback = {'Yes (default)' 'No'};
    rrArtMethod = { 'Shape-preserving piecewise cubic (default)' ...
        'Linear' 'Cubic' 'Nearest neighbor' 'Next neighbor' 'Previous neighbor' 'Spline'  ...
        'Cubic convolution' 'Modified Akima cubic' 'Remove them'};
    linefreq = {'60 Hz (US)' '50 Hz (Europe)'};
    refmethod = {'Infinity (default)' 'Average' 'Off'};
    filttype = {'Causal nonlinear' 'Non-causal linear (default)'};
    eeginterp = {'Yes (default)' 'No'};
    icamethod = {'Picard (fast)' 'Infomax (default)' 'Modified infomax (long but replicable)'};
    spectypes = {'Normalized Lomb-Scargle periodogram (default)' 'Lomb-Scargle periodogram' 'Welch (requires resampling)' 'FFT (requires resampling)'};
    hrvnorm = {'Yes' 'No (default)'};
    freqrange = '[1 40]';
    wintype = {'hamming' 'hann' 'rectwin' 'blackmannharris'};
    freqbounds = {'Conventional (e.g., alpha = 8-13 Hz)' 'Individualized (e.g., alpha = 7.8-12.3 Hz)'};
    winlen = '2';
    eegnorm = {'None (uV^2/Hz)' 'Decibels (default)' 'Decibels + divided by total power'};
    asynorm = {'None' 'Divided by total power'};

    % Callback functions
    cleanHEART = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_heart'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_heart'),'enable','off'); end";
    cleanEEG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_eeg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_eeg'),'enable','off'); end";
    hrv = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','hrv_features'),'enable','on'); else, set(findobj(gcbf,'userdata','hrv_features'),'enable','off'); end";
    hrvfreq = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','hrv_freq'),'enable','on'); else, set(findobj(gcbf,'userdata','hrv_freq'),'enable','off'); end";
    eeg = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','eeg_features'),'enable','on'); else, set(findobj(gcbf,'userdata','eeg_features'),'enable','off'); end";
    eegfreq = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','eeg_freq'),'enable','on'); else, set(findobj(gcbf,'userdata','eeg_freq'),'enable','off'); end";
    
    % GUI
    uilist = { ...
        {'style' 'checkbox' 'string' 'Preprocess ECG' 'fontweight' 'bold' 'tag' 'clean_heart' 'callback' cleanHEART 'value' 1} ...
        {} {'style' 'text' 'string' 'Peak threshold to detect R peaks:' } {'style' 'edit' 'string' '0.6' 'tag' 'ecg_peakthresh' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Perform searchback to detect R peaks:' } {'style' 'popupmenu' 'string' searchback 'tag' 'ecg_searchback' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Refractory period to detect R peaks:' } {'style' 'edit' 'string' '0.25' 'tag' 'ecg_refperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Physiologic limits to detect RR artifacts:' } {'style' 'edit' 'string' '[.375 2]' 'tag' 'rr_physlim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Gap limit to detect RR artifacts:' } {'style' 'edit' 'string' '2' 'tag' 'rr_gaplim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Change limit to detect RR artifacts:' } {'style' 'edit' 'string' '0.2' 'tag' 'rr_changelim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Interpolation method to deal with RR artifacts:' } {'style' 'popupmenu' 'string' rrArtMethod 'tag' 'rr_correct' 'enable' 'on' 'userdata' 'clean_heart' } ...
        {'style' 'checkbox' 'string' 'Preprocess EEG' 'fontweight' 'bold' 'tag' 'clean_eeg' 'callback' cleanEEG 'value' 1} ...
        {} {'style' 'text' 'string' 'Re-reference data to:' } {'style' 'popupmenu' 'string' refmethod 'tag' 'ref' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Power line noise (Hz):' } {'style' 'popupmenu' 'string' linefreq 'tag' 'linenoise' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '40' 'tag' 'lowpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Filter type:' } {'style' 'popupmenu' 'string' filttype 'tag' 'filttype' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Longest flat lines before removing channel (in sec):' } {'style' 'edit' 'string' '5' 'tag' 'flatline' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Minimum correlation before removing channel (.5-.9):' } {'style' 'edit' 'string' '.65' 'tag' 'corrThresh' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Max portion tolerated before removing channel (0.1-0.5):' } {'style' 'edit' 'string' '.33' 'tag' 'maxBad' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Interpolate EEG channels after removal' } {'style' 'popupmenu' 'string' eeginterp 'tag' 'eeg_interp' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Threshold to reject bad segments with ASR (1-100):' } {'style' 'edit' 'string' '30' 'tag' 'asr_cutoff' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Available RAM to use for ASR (in %):' } {'style' 'edit' 'string' '85' 'tag' 'asr_mem' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'ICA method to extract artifactual components:' } {'style' 'popupmenu' 'string' icamethod 'tag' 'icamethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {'style' 'checkbox' 'string' 'Visualize preprocessings' 'tag' 'vis_cleaning' 'fontweight' 'bold' 'value' 1}  ...
        {} ...
        {'style' 'checkbox' 'string' 'Compute HRV features' 'fontweight' 'bold' 'tag' 'hrv_features' 'callback' hrv 'value' 1} ...
        {} {'style' 'checkbox' 'string' ' Time domain (SDNN, RMSSD, pNN50)' 'tag' 'hrv_time' 'value' 1 'userdata' 'hrv_features' } {} ...
        {} {'style' 'checkbox' 'string' ' Frequency domain (ULF, VLF, LF, HF, LF/HF, Total power)' 'tag' 'hrv_frequency' 'value' 1 'userdata' 'hrv_features' 'callback' hrvfreq} {} ...
        {} {'style' 'edit' 'string' '' 'tag' 'hrv_freq_opts' 'userdata' 'hrv_freq'} {'style' 'pushbutton' 'string' 'Freq. options' 'callback' {@hrvfreqparam spectypes hrvnorm} } ...
        {} {'style' 'checkbox' 'string' ' Nonlinear domain (Poincaré, PRSA, entropy)' 'tag' 'hrv_nonlinear' 'value' 1 'userdata' 'hrv_features'} {} ...
        {} ...
        {'style' 'checkbox' 'string' 'Compute EEG features' 'fontweight' 'bold' 'tag' 'eeg_features' 'callback' eeg 'value' 1} ...
        {} {'style' 'checkbox' 'string' ' Frequency domain (band-power, IAF, asymmetry)' 'tag' 'eeg_frequency' 'value' 1 'userdata' 'eeg_features' 'callback' eegfreq} {} ...
        {} {'style' 'edit' 'string' '' 'tag' 'eeg_freq_opts' 'userdata' 'eeg_freq'} {'style' 'pushbutton' 'string' 'Freq. options' 'callback' {@eegfreqparam freqrange wintype freqbounds winlen eegnorm asynorm} } ...
        {} {'style' 'checkbox' 'string' ' Nonlinear domain (entropy)' 'tag' 'eeg_nonlinear' 'value' 1 'userdata' 'eeg_features'} {} ...
        {} ...
        {'style' 'checkbox' 'string' ' Use parallel computing' 'tag' 'parpool' 'value' 1 } ...
        {'style' 'checkbox' 'string' ' Use GPU computing' 'tag' 'gpu' 'value' 0 } ...
        };

    uigeom = {
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        .3 ...
        .3 ...
        [.01 .03 .01] ...
        [.01 .03 .01] ...
        [.03 .01 .01] ...
        [.01 .03 .01] ...
        .3 ...
        .3 ...
        [.01 .03 .01] ...
        [.03 .01 .01] ...
        [.01 .03 .01] ...
        .3 ...
        .3 ...
        .3 ...
        };
    % warning off  % for multi-line text warning
    [res,~,~,params2] = inputgui(uigeom,uilist,'pophelp(''brainbeats_process'')','BrainBeats: parameters for Features mode',EEG);
    % warning on
    if isempty(res), abort = true; return; end % Abort if no input

%% GUI for Features mode with PPG
elseif strcmp(params.analysis, 'features') && strcmp(params.heart_signal, 'ppg')

    % dropdown options
    rrArtMethod = { 'Shape-preserving piecewise cubic (default)' ...
        'Linear' 'Cubic' 'Nearest neighbor' 'Next neighbor' 'Previous neighbor' 'Spline'  ...
        'Cubic convolution' 'Modified Akima cubic' 'Remove them'};
    linefreq = {'60 Hz (US)' '50 Hz (Europe)'};
    refmethod = {'Infinity (default)' 'Average' 'Off'};
    filttype = {'Causal nonlinear' 'Non-causal linear (default)'};
    eeginterp = {'Yes (default)' 'No'};
    icamethod = {'Picard (fast)' 'Infomax (default)' 'Modified infomax (long but replicable)'};
    spectypes = {'Normalized Lomb-Scargle periodogram (default)' 'Lomb-Scargle periodogram' 'Welch (requires resampling)' 'FFT (requires resampling)'};
    hrvnorm = {'Yes' 'No (default)'};
    freqrange = '[1 40]';
    wintype = {'hamming' 'hann' 'rectwin' 'blackmannharris'};
    freqbounds = {'Conventional (e.g., alpha = 8-13 Hz)' 'Individualized (e.g., alpha = 7.8-12.3 Hz)'};
    winlen = '2';
    eegnorm = {'None (uV^2/Hz)' 'Decibels (default)' 'Decibels + divided by total power'};
    asynorm = {'None' 'Divided by total power'};

    % Callback functions
    cleanHEART = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_heart'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_heart'),'enable','off'); end";
    cleanEEG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_eeg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_eeg'),'enable','off'); end";
    hrv = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','hrv_features'),'enable','on'); else, set(findobj(gcbf,'userdata','hrv_features'),'enable','off'); end";
    hrvfreq = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','hrv_freq'),'enable','on'); else, set(findobj(gcbf,'userdata','hrv_freq'),'enable','off'); end";
    eeg = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','eeg_features'),'enable','on'); else, set(findobj(gcbf,'userdata','eeg_features'),'enable','off'); end";
    eegfreq = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','eeg_freq'),'enable','on'); else, set(findobj(gcbf,'userdata','eeg_freq'),'enable','off'); end";
    
    % GUI
    uilist = { ...
        {'style' 'checkbox' 'string' 'Preprocess PPG' 'fontweight' 'bold' 'tag' 'clean_heart' 'callback' cleanHEART 'value' 1} ...
        {} {'style' 'text' 'string' 'Learning period to detect R waves (in s):' } {'style' 'edit' 'string' '8' 'tag' 'ppg_learnperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Learning threshold to detect R waves:' } {'style' 'edit' 'string' '5' 'tag' 'ppg_learnthresh' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Eye-closing period to detect R waves (0.4-0.8 s)' } {'style' 'edit' 'string' '0.65' 'tag' 'ppg_eyeclosing' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Expectation period to detect R waves (in s):' } {'style' 'edit' 'string' '5' 'tag' 'ppg_expctperiod' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Slope window size to detect R waves (0.05-0.3):' } {'style' 'edit' 'string' '0.1' 'tag' 'ppg_slopewindow' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Physiologic limits to detect RR artifacts:' } {'style' 'edit' 'string' '[.375 2]' 'tag' 'rr_physlim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Gap limit to detect RR artifacts:' } {'style' 'edit' 'string' '2' 'tag' 'rr_gaplim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Change limit to detect RR artifacts:' } {'style' 'edit' 'string' '0.2' 'tag' 'rr_changelim' 'enable' 'on' 'userdata' 'clean_heart' }  ...
        {} {'style' 'text' 'string' 'Interpolation method to deal with RR artifacts:' } {'style' 'popupmenu' 'string' rrArtMethod 'tag' 'rr_correct' 'enable' 'on' 'userdata' 'clean_heart' 'value' 1 } ...
        {'style' 'checkbox' 'string' 'Preprocess EEG' 'fontweight' 'bold' 'tag' 'clean_eeg' 'callback' cleanEEG 'value' 1} ...
        {} {'style' 'text' 'string' 'Re-reference data to:' } {'style' 'popupmenu' 'string' refmethod 'tag' 'ref' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2 }  ...
        {} {'style' 'text' 'string' 'Power line noise (Hz):' } {'style' 'popupmenu' 'string' linefreq 'tag' 'linenoise' 'enable' 'on' 'userdata' 'clean_eeg'}  ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass' 'enable' 'on' 'userdata' 'clean_eeg'}  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '40' 'tag' 'lowpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Filter type:' } {'style' 'popupmenu' 'string' filttype 'tag' 'filttype' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Longest flat lines before removing channel (in sec):' } {'style' 'edit' 'string' '5' 'tag' 'flatline' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Minimum correlation before removing channel (.5-.9):' } {'style' 'edit' 'string' '.65' 'tag' 'corrThresh' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Max portion tolerated before removing channel (0.1-0.5):' } {'style' 'edit' 'string' '.33' 'tag' 'maxBad' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Interpolate EEG channels after removal' } {'style' 'popupmenu' 'string' eeginterp 'tag' 'eeg_interp' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Threshold to reject bad segments with ASR (1-100):' } {'style' 'edit' 'string' '30' 'tag' 'asr_cutoff' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Available RAM to use for ASR (in %):' } {'style' 'edit' 'string' '85' 'tag' 'asr_mem' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'ICA method to extract artifactual components:' } {'style' 'popupmenu' 'string' icamethod 'tag' 'icamethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {'style' 'checkbox' 'string' 'Visualize preprocessings' 'tag' 'vis_cleaning' 'fontweight' 'bold' 'value' 1}  ...
        {} ...
        {'style' 'checkbox' 'string' 'Compute HRV features' 'fontweight' 'bold' 'tag' 'hrv_features' 'callback' hrv 'value' 1} ...
        {} {'style' 'checkbox' 'string' ' Time domain (SDNN, RMSSD, pNN50)' 'tag' 'hrv_time' 'value' 1 'userdata' 'hrv_features' } {} ...
        {} {'style' 'checkbox' 'string' ' Frequency domain (ULF, VLF, LF, HF, LF/HF, Total power)' 'tag' 'hrv_frequency' 'value' 1 'userdata' 'hrv_features' 'callback' hrvfreq} {} ...
        {} {'style' 'edit' 'string' '' 'tag' 'hrv_freq_opts' 'userdata' 'hrv_freq'} {'style' 'pushbutton' 'string' 'Freq. options' 'callback' {@hrvfreqparam spectypes hrvnorm} } ...
        {} {'style' 'checkbox' 'string' ' Nonlinear domain (Poincaré, PRSA, entropy)' 'tag' 'hrv_nonlinear' 'value' 1 'userdata' 'hrv_features'} {} ...
        {} ...
        {'style' 'checkbox' 'string' 'Compute EEG features' 'fontweight' 'bold' 'tag' 'eeg_features' 'callback' eeg 'value' 1} ...
        {} {'style' 'checkbox' 'string' ' Frequency domain (band-power, IAF, asymmetry)' 'tag' 'eeg_frequency' 'value' 1 'userdata' 'eeg_features' 'callback' eegfreq} {} ...
        {} {'style' 'edit' 'string' '' 'tag' 'eeg_freq_opts' 'userdata' 'eeg_freq'} {'style' 'pushbutton' 'string' 'Freq. options' 'callback' {@eegfreqparam freqrange wintype freqbounds winlen eegnorm asynorm} } ...
        {} {'style' 'checkbox' 'string' ' Nonlinear domain (entropy)' 'tag' 'eeg_nonlinear' 'value' 1 'userdata' 'eeg_features'} {} ...
        {} ...
        {'style' 'checkbox' 'string' ' Use parallel computing' 'tag' 'parpool' 'value' 1 } ...
        {'style' 'checkbox' 'string' ' Use GPU computing' 'tag' 'gpu' 'value' 0 'enable' 'on' } ...
        };

    uigeom = {
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        .3 ...
        .3 ...
        [.01 .03 .01] ...
        [.01 .03 .01] ...
        [.03 .01 .01] ...
        [.01 .03 .01] ...
        .3 ...
        .3 ...
        [.01 .03 .01] ...
        [.03 .01 .01] ...
        [.01 .03 .01] ...
        .3 ...
        .3 ...
        .3 ...
        };
    [res,~,~,params2] = inputgui(uigeom,uilist,'pophelp(''brainbeats_process'')','BrainBeats: parameters for Features mode',EEG);
    if isempty(res), abort = true; return; end % Abort if no input


%% GUI for Removing heart artifacts with ECG

elseif strcmp(params.analysis, 'rm_heart') 

    % dropdown options
    linefreq = {'60 Hz (US)' '50 Hz (Europe)'};
    refmethod = {'Infinity (default)' 'Average' 'Off'};
    filttype = {'Causal nonlinear' 'Non-causal linear (default)'};
    eeginterp = {'Yes (default)' 'No'};
    icamethod = {'Picard (fast)' 'Infomax (default)' 'Modified infomax (long but replicable)'};

    % Callback functions
    cleanECG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_ecg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_ecg'),'enable','off'); end";
    cleanEEG = "if get(gcbo,'value'), set(findobj(gcbf,'userdata','clean_eeg'),'enable','on'); else, set(findobj(gcbf,'userdata','clean_eeg'),'enable','off'); end";

    % GUI
    uilist = { 
        {'style' 'checkbox' 'string' 'Preprocess ECG' 'fontweight' 'bold' 'tag' 'clean_ecg' 'callback' cleanECG 'value' 1} ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass_ecg' 'enable' 'on' 'userdata' 'clean_ecg'}  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '20' 'tag' 'lowpass_ecg' 'enable' 'on' 'userdata' 'clean_ecg' }  ...
        {'style' 'checkbox' 'string' 'Preprocess EEG' 'fontweight' 'bold' 'tag' 'clean_eeg' 'callback' cleanEEG 'value' 1} ...
        {} {'style' 'text' 'string' 'Re-reference data to:' } {'style' 'popupmenu' 'string' refmethod 'tag' 'ref' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Power line noise (Hz):' } {'style' 'popupmenu' 'string' linefreq 'tag' 'linenoise' 'enable' 'on' 'userdata' 'clean_eeg'}  ...
        {} {'style' 'text' 'string' 'Highpass filter:' } {'style' 'edit' 'string' '1' 'tag' 'highpass' 'enable' 'on' 'userdata' 'clean_eeg'}  ...
        {} {'style' 'text' 'string' 'Lowpass filter:' } {'style' 'edit' 'string' '40' 'tag' 'lowpass' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Filter type:' } {'style' 'popupmenu' 'string' filttype 'tag' 'filttype' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {} {'style' 'text' 'string' 'Longest flat lines before removing channel (in sec):' } {'style' 'edit' 'string' '5' 'tag' 'flatline' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Minimum correlation before removing channel (.5-.9):' } {'style' 'edit' 'string' '.65' 'tag' 'corrThresh' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Max portion tolerated before removing channel (0.1-0.5):' } {'style' 'edit' 'string' '.33' 'tag' 'maxBad' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Interpolate EEG channels after removal' } {'style' 'popupmenu' 'string' eeginterp 'tag' 'eeg_interp' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Threshold to reject bad segments with ASR (1-100):' } {'style' 'edit' 'string' '30' 'tag' 'asr_cutoff' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'Available RAM to use for ASR (in %):' } {'style' 'edit' 'string' '85' 'tag' 'asr_mem' 'enable' 'on' 'userdata' 'clean_eeg' }  ...
        {} {'style' 'text' 'string' 'ICA method to extract artifactual components:' } {'style' 'popupmenu' 'string' icamethod 'tag' 'icamethod' 'enable' 'on' 'userdata' 'clean_eeg' 'value' 2}  ...
        {'style' 'checkbox' 'string' 'Visualize preprocessings' 'tag' 'vis_cleaning' 'fontweight' 'bold' 'value' 1}  ...
        {} ...
        {'style' 'text' 'string' 'Minimum confidence level to remove heart components (%)' 'fontweight' 'bold'}  {'style' 'edit' 'string' '80' 'tag' 'conf_thresh' 'enable' 'on'} {}...
        {'style' 'checkbox' 'string' 'Boost mode (beta)' 'fontweight' 'bold' 'tag' 'boost' 'value' 0} ...
        };
    uigeom = {
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        [.01 .1 .08] ...
        .3 ...
        .3 ...
        [.1 .03 .01] ...
        .3 ...
        };
    [res,~,~,params2] = inputgui(uigeom,uilist,'pophelp(''brainbeats_process'')','BrainBeats: parameters for HEP mode',EEG);
    if isempty(res), abort = true; return; end % Abort if no input

end

%% Merge all parameters into params structure

fieldnames = fields(params2);
nFields = length(fieldnames);
for iField = 1:nFields
    fieldname = fieldnames{iField};
    params.(fieldname) = params2.(fieldname);
end
clear params2

%% Convert params to expected format

% logical parameters
params.vis_outputs = logical(params.vis_outputs);
params.save = logical(params.save);
if isfield(params, 'clean_heart') && ~isempty(params.clean_heart)
    params.clean_heart = logical(params.clean_heart);
else
    params.clean_heart = false;
end
if isfield(params, 'clean_eeg') && ~isempty(params.clean_eeg)
    params.clean_eeg = logical(params.clean_eeg);
else
    params.clean_eeg = false;
end
if isfield(params, 'vis_cleaning') && ~isempty(params.vis_cleaning)
    params.vis_cleaning = logical(params.vis_cleaning);
end
if isfield(params, 'keep_heart') && ~isempty(params.keep_heart)
    params.keep_heart = logical(params.keep_heart);
end
if isfield(params, 'ecg_searchback') && ~isempty(params.ecg_searchback)
    params.ecg_searchback = logical(params.ecg_searchback);
end
if isfield(params, 'hrv_features') && ~isempty(params.hrv_features)
    params.hrv_features = logical(params.hrv_features);
end
if isfield(params, 'hrv_time') && ~isempty(params.hrv_time)
    params.hrv_time = logical(params.hrv_time);
end
if isfield(params, 'hrv_frequency') && ~isempty(params.hrv_frequency)
    params.hrv_frequency = logical(params.hrv_frequency);
end
if isfield(params, 'hrv_norm') && ~isempty(params.hrv_norm)
    params.hrv_norm = logical(params.hrv_norm);
end
if isfield(params, 'hrv_nonlinear') && ~isempty(params.hrv_nonlinear)
    params.hrv_nonlinear = logical(params.hrv_nonlinear);
end
if isfield(params, 'eeg_time') && ~isempty(params.eeg_time)
    params.eeg_time = logical(params.eeg_time);
end
if isfield(params, 'eeg_frequency') && ~isempty(params.eeg_frequency)
    params.eeg_frequency = logical(params.eeg_frequency);
end
if isfield(params, 'eeg_nonlinear') && ~isempty(params.eeg_nonlinear)
    params.eeg_nonlinear = logical(params.eeg_nonlinear);
end
if isfield(params, 'parpool') && ~isempty(params.parpool)
    params.parpool = logical(params.parpool);
else
    params.parpool = false;
end
if isfield(params, 'gpu') && ~isempty(params.gpu)
    params.gpu = logical(params.gpu);
else
    params.gpu = false;
end
if isfield(params, 'boost') && ~isempty(params.boost)
    params.boost = logical(params.boost);
end

% RR artfact correction method
if isfield(params, 'rr_correct') && ~isempty(params.rr_correct)
    switch params.rr_correct
        case 1
            params.rr_correct = 'pchip';  % default
        case 2
            params.rr_correct = 'linear';
        case 3
            params.rr_correct = 'cubic';
        case 4
            params.rr_correct = 'nearest';
        case 5
            params.rr_correct = 'next';
        case 6
            params.rr_correct = 'previous';
        case 7
            params.rr_correct = 'spline';
        case 8
            params.rr_correct = 'cubic';
        case 9
            params.rr_correct = 'makima';
        case 'Remove'
            params.rr_correct = 'remove';
    end
end
if isfield(params, 'ecg_peakthresh') && ~isempty(params.ecg_peakthresh)
    params.ecg_peakthresh = str2double(params.ecg_peakthresh);
end
if isfield(params, 'ecg_refperiod') && ~isempty(params.ecg_refperiod)
    params.ecg_refperiod = str2double(params.ecg_refperiod);
end
if isfield(params, 'ppg_learnperiod') && ~isempty(params.ppg_learnperiod)
    params.ppg_learnperiod = str2double(params.ppg_learnperiod);
end
if isfield(params, 'ppg_learnthresh') && ~isempty(params.ppg_learnthresh)
    params.ppg_learnthresh = str2double(params.ppg_learnthresh);
end
if isfield(params, 'ppg_eyeclosing') && ~isempty(params.ppg_eyeclosing)
    params.ppg_eyeclosing = str2double(params.ppg_eyeclosing);
end
if isfield(params, 'ppg_expctperiod') && ~isempty(params.ppg_expctperiod)
    params.ppg_expctperiod = str2double(params.ppg_expctperiod);
end
if isfield(params, 'ppg_slopewindow') && ~isempty(params.ppg_slopewindow)
    params.ppg_slopewindow = str2double(params.ppg_slopewindow);
end
if isfield(params, 'rr_physlim') && ~isempty(params.rr_physlim)
    params.rr_physlimlow = str2double(extractBefore(extractBetween(params.rr_physlim,'[',']'),' '));
    params.rr_physlimhigh = str2double(extractAfter(extractBetween(params.rr_physlim,'[',']'),' '));
    params = rmfield(params,'rr_physlim');
end
if isfield(params, 'rr_gaplim') && ~isempty(params.rr_gaplim)
    params.rr_gaplim = str2double(params.rr_gaplim);
end
if isfield(params, 'rr_changelim') && ~isempty(params.rr_changelim)
    params.rr_changelim = str2double(params.rr_changelim);
end
if isfield(params, 'highpass') && ~isempty(params.highpass)
    params.highpass = str2double(params.highpass);
end
if isfield(params, 'lowpass') && ~isempty(params.lowpass)
    params.lowpass = str2double(params.lowpass);
end
if isfield(params, 'flatline') && ~isempty(params.flatline)
    params.flatline = str2double(params.flatline);
end
if isfield(params, 'corrThresh') && ~isempty(params.corrThresh)
    params.corrThresh = str2double(params.corrThresh);
end
if isfield(params, 'maxBad') && ~isempty(params.maxBad)
    params.maxBad = str2double(params.maxBad);
end
if isfield(params, 'asr_cutoff') && ~isempty(params.asr_cutoff)
    params.asr_cutoff = str2double(params.asr_cutoff);
end
if isfield(params, 'asr_mem') && ~isempty(params.asr_mem)
    params.asr_mem = str2double(params.asr_mem);
end
if isfield(params, 'highpass_ecg') && ~isempty(params.highpass_ecg)
    params.highpass_ecg = str2double(params.highpass_ecg);
end
if isfield(params, 'lowpass_ecg') && ~isempty(params.lowpass_ecg)
    params.lowpass_ecg = str2double(params.lowpass_ecg);
end
if isfield(params, 'conf_thresh') && ~isempty(params.conf_thresh)
    params.conf_thresh = str2double(params.conf_thresh)/100;
end

% re-reference EEG
if isfield(params, 'ref')
    if params.ref == 1
        params.ref = 'infinity';
    elseif params.ref == 2
        params.ref = 'average';
    elseif params.ref == 3
        params.ref = 'off';
    end
end

% line noise and lowpass filter
if isfield(params, 'linenoise') 
    if params.linenoise == 1
        params.linenoise = 60;
    elseif params.linenoise == 2
        params.linenoise = 50;
    end        
    if isfield(params,'lowpass') && params.linenoise<params.lowpass
        warndlg(sprintf('The lowpass filter you selected will not remove power line noise artifacts and can lead to serious issues. We recommend that you adjust the lowpass cutoff to at least %g Hz.', params.linenoise-10))
        warning('The lowpass filter you selected will not remove power line noise artifacts and can lead to serious issues. We recommend that you adjust the lowpass cutoff to at least %g Hz.', params.linenoise-10)
    end
end

% filter type
if isfield(params, 'filttype')
    if params.filttype == 1
        params.filttype = 'causal';
    elseif params.filttype == 2
        params.filttype = 'noncausal';
    end
end

% method to detect bad epochs for HEP
if isfield(params, 'detectMethod')
    if params.detectMethod == 1
        params.detectMethod = 'quartiles';
    elseif params.detectMethod == 2
        params.detectMethod = 'grubbs';
    elseif params.detectMethod == 3
        params.detectMethod = 'mean';
    end
end

% HRV power params
if isfield(params, 'hrv_freq_opts') && ~isempty(params.hrv_freq_opts)
    idx = find(strcmp(params.hrv_freq_opts,'hrvspec'));
    if strcmp(params.hrv_freq_opts{idx+1}, '1')
        params.hrv_spec = 'LombScargle_norm';
    elseif strcmp(params.hrv_freq_opts{idx+1}, '2')
        params.hrv_spec = 'LombScargle';
    elseif strcmp(params.hrv_freq_opts{idx+1}, '3')
        params.hrv_spec = 'welch';
    elseif strcmp(params.hrv_freq_opts{idx+1}, '4')
        params.hrv_spec = 'fft';
    end
    
    idx = find(strcmp(params.hrv_freq_opts,'winoverlap'));
    params.hrv_overlap = str2double(params.hrv_freq_opts(idx+1))/100; % in ratio

    idx = find(strcmp(params.hrv_freq_opts,'hrvnorm'));
    if strcmp(params.hrv_freq_opts(idx+1),'1')
        params.hrv_norm = true;
    elseif strcmp(params.hrv_freq_opts(3,:),'2')
        params.hrv_norm = false;
    end

    params = rmfield(params, 'hrv_freq_opts');
end

% EEG power params
if isfield(params, 'eeg_freq_opts') && ~isempty(params.eeg_freq_opts)
    idx = find(strcmp(params.eeg_freq_opts,'frange'));
    lowfreq = str2double(extractBefore(extractBetween(params.eeg_freq_opts{idx+1},'[',']'),' '));
    highfreq = str2double(extractAfter(extractBetween(params.eeg_freq_opts{idx+1},'[',']'),' '));
    params.eeg_frange = [lowfreq highfreq];
    
    idx = find(strcmp(params.eeg_freq_opts,'wintype'));
    params.eeg_wintype = params.eeg_freq_opts{idx+1};

    idx = find(strcmp(params.eeg_freq_opts,'winoverlap'));
    params.eeg_winoverlap = str2double(params.eeg_freq_opts(idx+1)); % in %

    idx = find(strcmp(params.eeg_freq_opts,'winlen'));
    params.eeg_winlen = str2double(params.eeg_freq_opts(idx+1)); % in s

    idx = find(strcmp(params.eeg_freq_opts,'freqbounds'));
    tmp = params.eeg_freq_opts{idx+1};
    if contains(tmp,'Conventional')
        params.eeg_freqbounds = 'conventional';
    else
        params.eeg_freqbounds = 'individualizaed';
    end

    idx = find(strcmp(params.eeg_freq_opts,'eegnorm'));
    tmp = params.eeg_freq_opts{idx+1};
    if contains(tmp,'none')
        params.eeg_norm = 0;
    elseif contains(tmp,'default')
        params.eeg_norm = 1;  % decibels
    elseif contains(tmp,'power')
        params.eeg_norm = 2;  % divide by total power
    end        

    idx = find(strcmp(params.eeg_freq_opts,'asynorm'));
    tmp = params.eeg_freq_opts{idx+1};
    if contains(tmp,'None')
        params.asynorm = false;
    else
        params.asynorm = true;
    end        

    params = rmfield(params, 'eeg_freq_opts');
end

if isfield(params, 'eeg_interp') && ~isempty(params.eeg_interp)
    if params.eeg_interp == 1
        params.eeg_interp = true;
    else
        params.eeg_interp = false;
    end
end
if isfield(params, 'ibi_size') && ~isempty(params.ibi_size)
    params.ibi_size = str2double(params.ibi_size);
end

% if HRV preprocessing is turned off
if isfield(params, 'clean_heart') && params.clean_heart == 0  && ~strcmp(params.analysis,'rm_heart')
    if strcmp(params.heart_signal,'ecg')
        params = rmfield(params,'ecg_peakthresh');
        params = rmfield(params,'ecg_searchback');
        params = rmfield(params,'ecg_refperiod');
    else
        params = rmfield(params,'ppg_learnperiod');
        params = rmfield(params,'ppg_learnthresh');
        params = rmfield(params,'ppg_eyeclosing');
        params = rmfield(params,'ppg_expctperiod');
        params = rmfield(params,'ppg_slopewindow');
    end
    params = rmfield(params,'rr_gaplim');
    params = rmfield(params,'rr_changelim');
    params = rmfield(params,'rr_correct');
    params = rmfield(params,'rr_physlimlow');
    params = rmfield(params,'rr_physlimhigh');
end

% remove heart components
if ~params.clean_eeg && ~strcmp(params.analysis, 'rm_heart')
    params = rmfield(params,'ref');
    params = rmfield(params,'highpass');
    params = rmfield(params,'lowpass');
    params = rmfield(params,'filttype');
    params = rmfield(params,'flatline');
    params = rmfield(params,'corrThresh');
    params = rmfield(params,'maxBad');
    if strcmp(params.analysis,'hep')
        params = rmfield(params,'detectMethod');
    elseif strcmp(params.analysis,'features')
        params = rmfield(params,'asr_cutoff');
        params = rmfield(params,'asr_mem');
    end
    params = rmfield(params,'icamethod');
end

% no preprocessings, turn OFF visualization
if ~params.clean_eeg && ~params.clean_heart
    params.vis_cleaning = false;
end


%% Button to get options for HRV frequency estimation

function hrvfreqparam(obj, evt, spectypes, hrvnorm)
uilist = {
    {'style' 'text' 'string' 'Method to estimate HRV power' } {'style' 'popupmenu' 'string' spectypes 'tag' 'hrv_spec'}  ...
    {} ...
    {'style' 'text' 'string' 'Window overlap (in %):' } {'style' 'edit' 'string' '25' 'tag' 'hrv_overlap' }  ...
    {} ...
    {'style' 'text' 'string' 'Normalize power' } {'style' 'popupmenu' 'string' hrvnorm 'tag' 'hrv_normc' 'value' 2}  ...
    };
uigeom = {
    [.2 .3]
    .3
    [.2 .1]
    .3
    [.2 .2]
    };
result = inputgui(uigeom, uilist, 'help(''get_hrv_features'')', 'HRV frequency domain parameters');
if isempty(result), return, end
% out = { 'hrvspec' spectypes{result{1}} 'winoverlap' result{2} 'hrvnorm' hrvnorm{result{3}} };
out = { 'hrvspec' result{1} 'winoverlap' result{2} 'hrvnorm' result{3} };
set(findobj(gcbf, 'tag', 'hrv_freq_opts'), 'string', out );
% set(findobj(gcbf, 'tag', 'hrv_spec'), 'string', result{1} );
% set(findobj(gcbf, 'tag', 'hrv_overlap'), 'string',  str2double(result{2})/100);
% set(findobj(gcbf, 'tag', 'hrv_norm'), 'string', result{3});

%% Button to get options for EEG frequency features

function eegfreqparam(obj, evt, freqrange, wintype, freqbounds, winlen, eegnorm, asynorm)
uilist = {
    {'style' 'text' 'string' 'Overall frequency range' 'fontweight' 'bold'} {'style' 'edit' 'string' freqrange 'tag' 'eeg_freqrange'}  ...
    {} ...
    {'style' 'text' 'string' 'Window type (in %):' 'fontweight' 'bold'} {'style' 'popupmenu' 'string' wintype 'tag' 'eeg_wintype' }  ...
    {} ...
    {'style' 'text' 'string' 'Window overlap (in %):' 'fontweight' 'bold'} {'style' 'edit' 'string' '50' 'tag' 'eeg_overlap' }  ...
    {} ...
    {'style' 'text' 'string' 'Window length (in s):' 'fontweight' 'bold'} {'style' 'edit' 'string' winlen 'tag' 'eeg_winlen' }  ...
    {} ...
    {'style' 'text' 'string' 'Frequency bands' 'fontweight' 'bold'} {'style' 'popupmenu' 'string' freqbounds 'tag' 'eeg_freqbounds' }  ...
    {} ...
    {'style' 'text' 'string' 'Band-power normalization' 'fontweight' 'bold'} {'style' 'popupmenu' 'string' eegnorm 'tag' 'eeg_norm' 'value' 2}  ...
    {} ...
    {'style' 'text' 'string' 'Alpha asymmerty normalization' 'fontweight' 'bold'} {'style' 'popupmenu' 'string' asynorm 'tag' 'asy_norm' }  ...
    };
uigeom = {
    [.1 .1]
    .3
    [.1 .1]
    .3
    [.1 .1]
    .3
    [.1 .1]
    .3
    [.2 .2]
    .3
    [.2 .2]
    .3
    [.1 .1]
    };
result = inputgui(uigeom, uilist, 'help(''get_eeg_features'')', 'EEG frequency domain parameters');
if isempty(result), return, end
out = { 'frange' result{1} 'wintype' wintype{result{2}} 'winoverlap' result{3} ...
    'winlen' result{4} 'freqbounds' freqbounds{result{5}} 'eegnorm' eegnorm{result{6}} ...
    'asynorm' asynorm{result{7}} };
set(findobj(gcbf, 'tag', 'eeg_freq_opts'), 'string', out );
